Все задачи из этого набора должны быть выполнены в функциональном стиле.


Задача 3-1: (2 балла)

на вход программы приходит list целых.
Программа считает среднее для n выбранных элементов коллекции.
Затем случайно перемешивает элементы списка, считает среднее для n элементов на тех же позициях, что были выбраны в первый раз.
Такая процедура повторяется n раз.
Затем вычисляется среднее по всем замерам.

Как это значение будет отличаться от среднего, посчитанного по всем элементам списка? Зависит ли результат от n? Можно ли подобрать такие параметры, чтобы получать среднее по всем элементам? Как будет соотноситься количество необходимых для этого операций с обычным способом вычисления среднего (все элементы сложить и поделить на количество)? Как влияет вид исходного массива (набор элементов, повторения и т.д.) на результат?

Задача 3-2: (2 балла)

На вход программы приходит строка.
Программа определяет, является ли строка палиндромом.
Результат выдается в виде строки "да/нет"

(https://ru.wikipedia.org/wiki/SATOR)

Задача 3-3: (3 балла)

На вход программы приходит: list с целыми, set с целыми. Числа в обеих коллекциях выбраны из одного набора, но встречаться могут не все числа из набора, повторы допускаются. Пример: list = [1, 2, 3, 2, 2, 4, 6], set = [1, 2, 4], набор: 1..6
Программа формирует список списков такой, что:
в нем содержится столько списоков, сколько элементов в set,
для каждого элемента из set в соответствующем списке хранятся номера,
под которыми такой элемент встречался в исходном list.
пример результата(для приведенных выше входных данных): [[0],[1,3,4],[5]]

Задача 3-4: (1 балл)

На вход программы приходит строка и два целых a, b.
Программа выдает подстроку, начинающуюся с символа под номером a, заканчивающуюся символом под номером b.

Задача 3-5: (3 балла)

На вход программы приходит set из элементов какого-либо типа.
На выход программа выдает список списков со всем возможными комбинациями элементов из входного множества. Можно ли придумать здесь какую-то оптимизацию?

Задача 3-6: (6 баллов)

На вход программы приходит описание графа (разработать формат самостоятельно).
Программа раскрашивает вершины графа и выдает результат (раскраску).

Реализовать жадный алгоритм.
(https://en.wikipedia.org/wiki/Greedy_coloring)

Когда он плохо работает? Что можно предложить взамен? Реализовать более эффективный алгоритм (с т.з. количества используемых цветов) и показать его эффективность.

Задача 3-7: (10 баллов)

На вход программы приходит информация о списочном составе 11 класса в школе в виде списка списков (пример: [["Петров Петр", "Иванов Иван", "Сидоров Сидр"],["Марианова Мария", "Иваненко Иванен"],["Лев Львов"]]). Во входных данных также содержится информация о поле учеников, а также о том об отношении "нравится" (пример: "Марианова Мария", ж, нравится: ["Петров Петр", "Лев Львов"]). 
Программа призвана помогать учителям снижать отвлекающий фактор при подготовке к экзаменам. В качестве результат программа выдает такое разбиение по классам, что для каждого ученика минимизируется количество одноклассников, которые бы ему "нравились".

Какой алгоритм тут использовать?
Какова будет его эффективность?

